generator client {
	provider = "prisma-client-js"
}

datasource db {
	provider	= "postgresql"
	url			= env("DATABASE_URL")
}

model User {
	// auth specific fields
	id				String				@id @default(cuid())
	email			String				@unique @db.VarChar(254)
	emailVerified	DateTime?
	image			String?
	accounts		Account[]
	sessions		Session[]

	// Optional for WebAuthn support
	Authenticator Authenticator[]

	createdAt		DateTime			@default(now())
	updatedAt		DateTime			@updatedAt


	// app specific fields
	name			String?				@db.VarChar(150)
	ownedEvents		Event[]				@relation("EventOwner")
	participations	EventParticipant[]
	giftsAdded		Gift[]				@relation("GiftsAddedByUser")
	giftsReceived	Gift[]				@relation("GiftsRecipientUser")
	giftsReserved	Gift[]				@relation("GiftsReservedByUser")

	@@map("users")
}

model Account {
	userId				String
	type				String
	provider			String
	providerAccountId	String
	refresh_token		String?
	access_token		String?
	expires_at			Int?
	token_type			String?
	scope				String?
	id_token			String?
	session_state		String?

	createdAt DateTime @default(now())
	updatedAt DateTime @updatedAt

	user User @relation(fields: [userId], references: [id], onDelete: Cascade)
 
	@@id([provider, providerAccountId])
}

model Session {
	sessionToken	String		@unique
	userId			String
	expires			DateTime
	user			User		@relation(fields: [userId], references: [id], onDelete: Cascade)

	createdAt DateTime @default(now())
	updatedAt DateTime @updatedAt
}
 
model VerificationToken {
	identifier	String
	token		String
	expires		DateTime
 
	@@id([identifier, token])
}

// Optional for WebAuthn support
model Authenticator {
	credentialID			String		@unique
	userId					String
	providerAccountId		String
	credentialPublicKey		String
	counter					Int
	credentialDeviceType	String
	credentialBackedUp		Boolean
	transports				String?

	user User @relation(fields: [userId], references: [id], onDelete: Cascade)

	@@id([userId, credentialID])
}




model Event {
	id					Int					@id @default(autoincrement())
	name				String				@db.VarChar(100)
	date				DateTime			@db.Date
	description			String
	ownerId				String				@map("owner_id")
	createdAt			DateTime			@default(now()) @db.Timestamptz(6) @map("created_at")

	owner				User				@relation("EventOwner", fields: [ownerId], references: [id], onDelete: Cascade, onUpdate: NoAction)
	participants		EventParticipant[]
	gifts				Gift[]
	invites				EventInvite[]

	@@map("events")
}

model EventParticipant {
	userId		String		@map("user_id")
	eventId		Int			@map("event_id")
	isShopper	Boolean		@default(false) @map("is_shopper")
	isRecipient	Boolean		@default(false) @map("is_recipient")

	event		Event		@relation(fields: [eventId], references: [id], onDelete: Cascade, onUpdate: NoAction)
	user		User		@relation(fields: [userId], references: [id], onDelete: Cascade, onUpdate: NoAction)

	@@id([userId, eventId])
	@@index([eventId], map: "idx_event_user_event_id")
	@@map("event_user")
}

model EventInvite {
  id         Int      @id @default(autoincrement())
  eventId    Int
  email      String
  token      String   @unique
  expiresAt  DateTime
  used       Boolean  @default(false)

  event      Event    @relation(fields: [eventId], references: [id])
}


model Gift {
	id					Int			@id @default(autoincrement())
	itemName			String		@map("item_name")
	link				String
	eventId				Int?		@map("event_id")
	recipientUserId		String		@map("recipient_user_id")
	addedByUserId		String		@map("added_by_user_id")
	reservedByUserId	String?		@map("reserved_by_user_id")
	createdAt			DateTime	@default(now()) @db.Timestamptz(6) @map("created_at")

	event				Event?		@relation(fields: [eventId], references: [id], onUpdate: NoAction)
	addedBy				User		@relation("GiftsAddedByUser", fields: [addedByUserId], references: [id], onDelete: Cascade, onUpdate: NoAction)
	recipient			User		@relation("GiftsRecipientUser", fields: [recipientUserId], references: [id], onDelete: Cascade, onUpdate: NoAction)
	reservedBy			User?		@relation("GiftsReservedByUser", fields: [reservedByUserId], references: [id], onUpdate: NoAction)

	@@map("gifts")
}

